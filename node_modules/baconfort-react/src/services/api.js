// Configuraci√≥n de la API - Usa VITE_API_URL o Railway por defecto
const isProduction = window.location.hostname !== 'localhost' && window.location.hostname !== '127.0.0.1';
const API_BASE_URL = isProduction 
  ? import.meta.env.VITE_API_URL || 'https://noble-nourishment-production.up.railway.app/api'  // Railway por defecto
  : import.meta.env.VITE_API_URL || 'http://localhost:5004/api';  // URL de desarrollo - Puerto actualizado a 5004

export const API_URL = API_BASE_URL;

// Utilidad para hacer requests a la API
const apiRequest = async (endpoint, options = {}) => {
  // Agregar timestamp para evitar cache
  const separator = endpoint.includes('?') ? '&' : '?';
  const timestampParam = `_t=${Date.now()}`;
  const url = `${API_BASE_URL}${endpoint}${separator}${timestampParam}`;
  
  // Obtener token de sesi√≥n actual
  const getAuthToken = () => {
    // Primero intentar obtener token JWT de admin directo
    const adminToken = localStorage.getItem('baconfort-token');
    if (adminToken) {
      // Verificar si es un token JWT v√°lido
      if (adminToken.startsWith('eyJ')) {
        // Es un JWT, verificar si contiene admin en el payload
        try {
          const payload = JSON.parse(atob(adminToken.split('.')[1]));
          if (payload.role === 'admin') {
            return adminToken;
          }
        } catch (e) {
          // Fall√≥ el parseo, tratar como token regular
        }
      }
      
      // Verificar si es un token de admin con prefijo espec√≠fico
      if (adminToken.startsWith('admin_token_') || adminToken.startsWith('LOCAL_') || adminToken.startsWith('BACONFORT_')) {
        return adminToken;
      }
      
      // Token regular de usuario
      return adminToken;
    }
    
    // Fallback a sesi√≥n de admin
    const savedSession = localStorage.getItem('baconfort_admin_session');
    const sessionData = savedSession ? JSON.parse(savedSession) : null;
    if (sessionData?.token) {
      return sessionData.token;
    }
    
    // Usar sessionId como √∫ltimo recurso (formato legacy)
    if (sessionData?.sessionId) {
      return sessionData.sessionId;
    }
    
    // Sin tokens v√°lidos
    return null;
  };

  const defaultOptions = {
    headers: {
      'Content-Type': 'application/json',
    },
  };

  // Agregar Authorization header solo si hay token
  const token = getAuthToken();
  console.log('üîë API: Token obtenido:', token ? `${token.substring(0, 20)}...` : 'NO TOKEN');
  if (token) {
    defaultOptions.headers['Authorization'] = `Bearer ${token}`;
    console.log('üîë API: Authorization header agregado');
  } else {
    console.log('‚ö†Ô∏è API: NO se agreg√≥ Authorization header - sin token');
  }

  const config = {
    ...defaultOptions,
    ...options,
    headers: {
      ...defaultOptions.headers,
      ...options.headers,
    },
  };

  try {
    const response = await fetch(url, config);
    
    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      
      // Manejar token expirado autom√°ticamente
      if (response.status === 401 && errorData.code === 'TOKEN_EXPIRED') {
        console.log('üîÑ Token expirado, intentando renovar...');
        
        // Intentar renovar el token
        const user = JSON.parse(localStorage.getItem('baconfort-user') || '{}');
        if (user.email) {
          try {
            const refreshResponse = await fetch(`${API_BASE_URL}/auth/refresh-token`, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
              },
              body: JSON.stringify({ email: user.email }),
            });
            
            if (refreshResponse.ok) {
              const refreshData = await refreshResponse.json();
              console.log('‚úÖ Token renovado exitosamente');
              
              // Actualizar token en localStorage
              localStorage.setItem('baconfort-token', refreshData.token);
              localStorage.setItem('baconfort-user', JSON.stringify(refreshData.user));
              
              // Reintentar la request original con el nuevo token
              const newConfig = {
                ...config,
                headers: {
                  ...config.headers,
                  'Authorization': `Bearer ${refreshData.token}`
                }
              };
              
              const retryResponse = await fetch(url, newConfig);
              if (retryResponse.ok) {
                return await retryResponse.json();
              }
            }
          } catch (refreshError) {
            console.error('‚ùå Error renovando token:', refreshError);
          }
        }
        
        // Si no se pudo renovar, redirigir a login
        console.log('‚ùå No se pudo renovar el token, redirigiendo a login...');
        localStorage.removeItem('baconfort-token');
        localStorage.removeItem('baconfort-user');
        
        // Solo redirigir si no estamos ya en la p√°gina de login
        if (!window.location.pathname.includes('/login') && !window.location.pathname.includes('/auth')) {
          window.location.href = '/login?reason=token_expired';
        }
      }
      
      throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
    }

    const data = await response.json();
    return data;
  } catch (error) {
    throw error;
  }
};

// Funciones espec√≠ficas de autenticaci√≥n
export const authAPI = {
  login: async (email, password) => {
    return apiRequest('/auth/login', {
      method: 'POST',
      body: JSON.stringify({ email, password }),
    });
  },
  
  refreshToken: async (email) => {
    return apiRequest('/auth/refresh-token', {
      method: 'POST',
      body: JSON.stringify({ email }),
    });
  },

  register: async (userData) => {
    return apiRequest('/auth/register', {
      method: 'POST',
      body: JSON.stringify(userData),
    });
  },

  profile: async () => {
    return apiRequest('/auth/me');
  },

  updateProfile: async (userData) => {
    return apiRequest('/auth/profile', {
      method: 'PUT',
      body: JSON.stringify(userData),
    });
  },

  changePassword: async (currentPassword, newPassword) => {
    return apiRequest('/auth/change-password', {
      method: 'PUT',
      body: JSON.stringify({ currentPassword, newPassword }),
    });
  },

  // Recuperaci√≥n de contrase√±a
  forgotPassword: async (email) => {
    console.log('üîç API: forgotPassword called with email:', email);
    console.log('üîç API: API_BASE_URL:', API_BASE_URL);
    
    try {
      const result = await apiRequest('/auth/forgot-password', {
        method: 'POST',
        body: JSON.stringify({ email }),
      });
      console.log('‚úÖ API: forgotPassword success:', result);
      return result;
    } catch (error) {
      console.error('‚ùå API: forgotPassword error:', error);
      throw error;
    }
  },

  resetPassword: async (token, newPassword) => {
    return apiRequest('/auth/reset-password', {
      method: 'POST',
      body: JSON.stringify({ token, newPassword }),
    });
  },
};

// Funciones de usuarios (para admin)
export const usersAPI = {
  getAll: async () => {
    return apiRequest('/users');
  },

  getById: async (id) => {
    return apiRequest(`/users/${id}`);
  },

  update: async (id, userData) => {
    return apiRequest(`/users/${id}`, {
      method: 'PUT',
      body: JSON.stringify(userData),
    });
  },

  delete: async (id) => {
    return apiRequest(`/users/${id}`, {
      method: 'DELETE',
    });
  },

  // Obtener estad√≠sticas de usuarios
  getStats: async () => {
    return apiRequest('/users/stats/summary');
  },
};

// Funciones de propiedades
export const propertiesAPI = {
  getAll: async () => {
    return apiRequest('/properties');
  },

  getById: async (id) => {
    return apiRequest(`/properties/${id}`);
  },

  create: async (propertyData) => {
    return apiRequest('/properties', {
      method: 'POST',
      body: JSON.stringify(propertyData),
    });
  },

  update: async (id, propertyData) => {
    return apiRequest(`/properties/${id}`, {
      method: 'PUT',
      body: JSON.stringify(propertyData),
    });
  },

  delete: async (id) => {
    return apiRequest(`/properties/${id}`, {
      method: 'DELETE',
    });
  },
};

// Funciones de rese√±as
export const reviewsAPI = {
  // Obtener rese√±as de una propiedad (p√∫blicas aprobadas)
  getPropertyReviews: async (propertyId, options = {}) => {
    const { limit = 10, page = 1, sort = '-createdAt' } = options;
    const params = new URLSearchParams({
      limit: limit.toString(),
      page: page.toString(),
      sort
    });
    
    return apiRequest(`/reviews/property/${propertyId}?${params}`);
  },

  // Enviar nueva rese√±a (desde frontend p√∫blico)
  submitReview: async (reviewData) => {
    return apiRequest('/reviews', {
      method: 'POST',
      body: JSON.stringify(reviewData)
    });
  },

  // Obtener todas las rese√±as para administraci√≥n (incluyendo pendientes)
  getAllReviews: async (filters = {}) => {
    const params = new URLSearchParams();
    Object.entries(filters).forEach(([key, value]) => {
      if (value !== undefined && value !== null) {
        params.append(key, value);
      }
    });
    // Agregar par√°metros por defecto
    if (!params.has('limit')) params.append('limit', '20');
    if (!params.has('page')) params.append('page', '1');
    if (!params.has('sort')) params.append('sort', '-createdAt');
    
    const queryString = params.toString();
    return apiRequest(`/reviews/admin${queryString ? `?${queryString}` : ''}`);
  },

  // Moderar rese√±a (aprobar/rechazar)
  moderateReview: async (reviewId, action, notes = '') => {
    const endpoint = action === 'approve' ? 'approve' : 'reject';
    return apiRequest(`/reviews/${reviewId}/${endpoint}`, {
      method: 'PUT',
      body: JSON.stringify({ notes }),
    });
  },

  // Destacar/quitar destaque de rese√±a
  toggleHighlight: async (reviewId, highlight) => {
    return apiRequest(`/reviews/${reviewId}/highlight`, {
      method: 'PATCH',
      body: JSON.stringify({ highlight }),
    });
  },

  // Eliminar rese√±a
  deleteReview: async (reviewId) => {
    return apiRequest(`/reviews/${reviewId}`, {
      method: 'DELETE',
    });
  },

  // Crear nueva rese√±a
  createReview: async (data) => {
    return apiRequest('/reviews', {
      method: 'POST',
      body: JSON.stringify(data),
    });
  }
};

// Funciones de reservas
export const reservationsAPI = {
  getAll: async () => {
    return apiRequest('/reservations');
  },

  getMyReservations: async () => {
    return apiRequest('/reservations/my');
  },

  getById: async (id) => {
    return apiRequest(`/reservations/${id}`);
  },

  create: async (reservationData) => {
    return apiRequest('/reservations', {
      method: 'POST',
      body: JSON.stringify(reservationData),
    });
  },

  updateStatus: async (id, status) => {
    return apiRequest(`/reservations/${id}/status`, {
      method: 'PUT',
      body: JSON.stringify({ status }),
    });
  },

  cancel: async (id) => {
    return apiRequest(`/reservations/${id}/cancel`, {
      method: 'PUT',
    });
  },

  // Actualizar informaci√≥n de pago de una reserva
  updatePayment: async (id, paymentData) => {
    return apiRequest(`/reservations/${id}/payment`, {
      method: 'PUT',
      body: JSON.stringify(paymentData),
    });
  },

  delete: async (id) => {
    return apiRequest(`/reservations/${id}`, {
      method: 'DELETE',
    });
  },

  // Obtener reservas por propiedad espec√≠fica
  getByProperty: async (propertyId) => {
    return apiRequest(`/reservations/property/${propertyId}`);
  },
};



// Funciones de galer√≠a de im√°genes (base de datos)
export const galleryAPI = {
  // Obtener todas las im√°genes de una propiedad
  getByProperty: async (propertyId) => {
    return apiRequest(`/gallery/${propertyId}`);
  },

  // Subir m√∫ltiples im√°genes
  uploadImages: async (propertyId, images, formData = null) => {
    // Si se pasa formData directamente (para archivos reales), usarlo
    if (formData) {
      return apiRequest(`/gallery/${propertyId}/upload`, {
        method: 'POST',
        headers: {
          // No incluir Content-Type para FormData, el navegador lo establecer√° autom√°ticamente
        },
        body: formData,
      });
    }
    
    // Para base64 o URLs de imagen
    return apiRequest(`/gallery/${propertyId}/upload-batch`, {
      method: 'POST',
      body: JSON.stringify({ images }),
    });
  },

  // Actualizar informaci√≥n de una imagen
  updateImage: async (imageId, updateData) => {
    return apiRequest(`/gallery/${imageId}`, {
      method: 'PUT',
      body: JSON.stringify(updateData),
    });
  },

  // Eliminar una imagen
  deleteImage: async (propertyId, imageId) => {
    return apiRequest(`/gallery/${propertyId}/images/${imageId}`, {
      method: 'DELETE',
    });
  },

  // Reordenar im√°genes
  reorderImages: async (propertyId, imageIds) => {
    return apiRequest(`/gallery/${propertyId}/reorder`, {
      method: 'PUT',
      body: JSON.stringify({ imageIds }),
    });
  },

  // Establecer imagen como portada
  setCoverImage: async (imageId) => {
    return apiRequest(`/gallery/${imageId}/cover`, {
      method: 'PUT',
    });
  }
};

// Funciones espec√≠ficas de propiedades
export const propertyAPI = {
  // Obtener una propiedad espec√≠fica
  getProperty: async (propertyId, options = {}) => {
    let url = `/properties/${propertyId}`;
    
    // Agregar cache-busting si se especifica
    if (options.cacheBust) {
      url += `?_t=${options.cacheBust}`;
    }
    
    const response = await apiRequest(url, {
      method: 'GET',
      headers: {
        'Cache-Control': 'no-cache, no-store, must-revalidate',
        'Pragma': 'no-cache',
        'Expires': '0'
      }
    });
    
    // Devolver la respuesta completa para que useProperty pueda verificar success
    return response;
  },

  // Obtener todas las propiedades
  getAllProperties: async () => {
    const response = await apiRequest('/properties', {
      method: 'GET',
    });
    
    // El backend devuelve {success: true, data: [...], pagination: {...}}
    // Extraer solo el array de propiedades
    return response.data || [];
  },

  // Actualizar una propiedad
  updateProperty: async (propertyId, data) => {
    const response = await apiRequest(`/properties/${propertyId}`, {
      method: 'PUT',
      body: JSON.stringify(data),
    });
    
    // El backend devuelve {success: true, data: {...}}
    // Extraer solo la propiedad actualizada
    return response.data || null;
  },

  // Crear nueva propiedad
  createProperty: async (data) => {
    const response = await apiRequest('/properties', {
      method: 'POST',
      body: JSON.stringify(data),
    });
    
    // El backend devuelve {success: true, data: {...}}
    // Extraer solo la propiedad creada
    return response.data || null;
  },

  // Eliminar una propiedad
  deleteProperty: async (propertyId) => {
    const response = await apiRequest(`/properties/${propertyId}`, {
      method: 'DELETE',
    });
    
    // El backend devuelve {success: true, message: "..."}
    return response;
  }
};

// API para promociones
export const promotionsAPI = {
  // Obtener todas las promociones
  getAll: async (filters = {}) => {
    const params = new URLSearchParams();
    Object.entries(filters).forEach(([key, value]) => {
      if (value !== undefined && value !== null) {
        params.append(key, value);
      }
    });
    const queryString = params.toString();
    return apiRequest(`/promotions${queryString ? `?${queryString}` : ''}`);
  },

  // Obtener promoci√≥n por ID
  getById: async (id) => {
    return apiRequest(`/promotions/${id}`);
  },

  // Crear nueva promoci√≥n
  create: async (data) => {
    return apiRequest('/promotions', {
      method: 'POST',
      body: JSON.stringify(data),
    });
  },

  // Actualizar promoci√≥n
  update: async (id, data) => {
    return apiRequest(`/promotions/${id}`, {
      method: 'PUT',
      body: JSON.stringify(data),
    });
  },

  // Eliminar promoci√≥n
  delete: async (id) => {
    return apiRequest(`/promotions/${id}`, {
      method: 'DELETE',
    });
  },

  // Cambiar estado activo/inactivo
  toggleStatus: async (id) => {
    return apiRequest(`/promotions/${id}/toggle-status`, {
      method: 'PUT',
    });
  },

  // Cambiar prioridad
  updatePriority: async (id, priority) => {
    return apiRequest(`/promotions/${id}/priority`, {
      method: 'PUT',
      body: JSON.stringify({ priority }),
    });
  },

  // Enviar promoci√≥n a suscriptores
  sendToSubscribers: async (id) => {
    return apiRequest(`/promotions/${id}/send-to-subscribers`, {
      method: 'POST',
    });
  }
};

// Funciones de conveniencia para mantener compatibilidad
export const getUserReservations = () => reservationsAPI.getMyReservations();
export const updateReservationStatus = (id, status) => reservationsAPI.updateStatus(id, status);

export { API_BASE_URL };

// Cache buster - Updated: 2025-06-29T20:20:00Z

// Verificaci√≥n de autenticaci√≥n mejorada
const checkAuthStatus = async () => {
  const token = localStorage.getItem('baconfort-token');
  
  if (!token) {
    return false;
  }
  
  try {
    const response = await fetch(`${API_BASE_URL}/auth/me`, {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json'
      }
    });
    
    if (response.ok) {
      const data = await response.json();
      return true;
    } else {
      return false;
    }
  } catch (error) {
    return false;
  }
};

// Exportar funci√≥n
window.checkAuthStatus = checkAuthStatus;

// ========================
// FUNCIONES DE CONSULTAS (INQUIRIES)
// ========================

// Obtener todas las consultas (para admin)
export const getAllInquiries = async (filters = {}) => {
  try {
    const queryParams = new URLSearchParams();
    
    if (filters.status) queryParams.append('status', filters.status);
    if (filters.page) queryParams.append('page', filters.page);
    if (filters.limit) queryParams.append('limit', filters.limit);
    
    const queryString = queryParams.toString();
    const endpoint = `/inquiries/admin/all${queryString ? `?${queryString}` : ''}`;
    
    return apiRequest(endpoint);
  } catch (error) {
    console.error('Error obteniendo consultas:', error);
    throw error;
  }
};

// Actualizar estado de una consulta (aprobar/rechazar)
export const updateInquiryStatus = async (inquiryId, status, adminResponse = '') => {
  try {
    return apiRequest(`/inquiries/${inquiryId}/status`, {
      method: 'PATCH',
      body: JSON.stringify({
        status,
        adminResponse
      })
    });
  } catch (error) {
    console.error('Error actualizando estado de consulta:', error);
    throw error;
  }
};

// Obtener consultas del usuario actual
export const getMyInquiries = async () => {
  try {
    return apiRequest('/inquiries/my-inquiries');
  } catch (error) {
    console.error('Error obteniendo mis consultas:', error);
    throw error;
  }
};

// Enviar nueva consulta (endpoint p√∫blico)
export const sendInquiry = async (inquiryData) => {
  try {
    return apiRequest('/inquiries', {
      method: 'POST',
      body: JSON.stringify(inquiryData)
    });
  } catch (error) {
    console.error('Error enviando consulta:', error);
    throw error;
  }
};

// Enviar nueva consulta (usuario autenticado)
export const sendAuthenticatedInquiry = async (inquiryData) => {
  try {
    return apiRequest('/inquiries/send', {
      method: 'POST',
      body: JSON.stringify(inquiryData)
    });
  } catch (error) {
    console.error('Error enviando consulta autenticada:', error);
    throw error;
  }
};

// Eliminar consulta (solo para admins)
export const deleteInquiry = async (inquiryId) => {
  try {
    return apiRequest(`/inquiries/${inquiryId}`, {
      method: 'DELETE'
    });
  } catch (error) {
    console.error('Error eliminando consulta:', error);
    throw error;
  }
};
